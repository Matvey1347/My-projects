<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Interactive Background</title>
      <style>
         body {
            margin: 0;
            overflow: hidden;
            background: #ffffff;
         }
         canvas {
            display: block;
         }
      </style>
   </head>
   <body>
      <canvas id="background"></canvas>
      <script>
         const canvas = document.getElementById("background");
         const ctx = canvas.getContext("2d");
         canvas.width = window.innerWidth;
         canvas.height = window.innerHeight;

         const particles = [];
         const particleCount = 150; // Увеличено количество частиц
         const maxDistance = 200; // Максимальная длина линии
         const mouseRadius = 150; // Радиус реакции на курсор

         // Создание частиц
         for (let i = 0; i < particleCount; i++) {
            particles.push({
               x: Math.random() * canvas.width,
               y: Math.random() * canvas.height,
               radius: Math.random() * 1 + 0.5, // Очень маленькие точки
               speedX: Math.random() * 0.3 - 0.15, // Медленное движение
               speedY: Math.random() * 0.3 - 0.15,
            });
         }

         // Позиция мыши
         const mouse = { x: canvas.width / 2, y: canvas.height / 2 }; // Начальная позиция в центре
         const movementOffset = { x: 0, y: 0 }; // Смещение фона

         window.addEventListener("mousemove", (event) => {
            // Рассчитываем смещение в зависимости от положения мыши
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            movementOffset.x = (event.x - centerX) * 0.02; // Маленькое смещение по X
            movementOffset.y = (event.y - centerY) * 0.02; // Маленькое смещение по Y

            // Обновляем позицию мыши
            mouse.x = event.x;
            mouse.y = event.y;
         });

         // Рисование частиц
         function drawParticles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach((particle) => {
               const dx = particle.x - mouse.x;
               const dy = particle.y - mouse.y;
               const distance = Math.sqrt(dx * dx + dy * dy);

               // Затемнение частиц рядом с курсором
               const darkness = distance < mouseRadius ? 1 - distance / mouseRadius : 0.2;
               const color = `rgba(0, 0, 0, ${darkness})`;

               ctx.beginPath();
               ctx.arc(particle.x + movementOffset.x, particle.y + movementOffset.y, particle.radius, 0, Math.PI * 2);
               ctx.fillStyle = color;
               ctx.fill();
               ctx.closePath();
            });
         }

         // Рисование линий между частицами
         function drawLines() {
            for (let i = 0; i < particles.length; i++) {
               for (let j = i + 1; j < particles.length; j++) {
                  const dx = particles[i].x - particles[j].x;
                  const dy = particles[i].y - particles[j].y;
                  const distance = Math.sqrt(dx * dx + dy * dy);

                  if (distance < maxDistance) {
                     const midX = (particles[i].x + particles[j].x) / 2;
                     const midY = (particles[i].y + particles[j].y) / 2;
                     const mouseDx = midX - mouse.x;
                     const mouseDy = midY - mouse.y;
                     const mouseDistance = Math.sqrt(mouseDx * mouseDx + mouseDy * mouseDy);

                     // Затемнение линий рядом с курсором
                     const lineDarkness = mouseDistance < mouseRadius ? 1 - mouseDistance / mouseRadius : 0.1;

                     ctx.beginPath();
                     ctx.moveTo(particles[i].x + movementOffset.x, particles[i].y + movementOffset.y);
                     ctx.lineTo(particles[j].x + movementOffset.x, particles[j].y + movementOffset.y);
                     ctx.strokeStyle = `rgba(0, 0, 0, ${lineDarkness})`;
                     ctx.lineWidth = 0.5; // Очень тонкие линии
                     ctx.stroke();
                     ctx.closePath();
                  }
               }
            }
         }

         // Обновление позиций частиц
         function updateParticles() {
            particles.forEach((particle) => {
               particle.x += particle.speedX;
               particle.y += particle.speedY;

               // Отражение частиц от краев экрана
               if (particle.x <= 0 || particle.x >= canvas.width) {
                  particle.speedX *= -1;
               }
               if (particle.y <= 0 || particle.y >= canvas.height) {
                  particle.speedY *= -1;
               }
            });
         }

         // Анимация
         function animate() {
            drawParticles();
            drawLines();
            updateParticles();
            requestAnimationFrame(animate);
         }

         animate();

         // Изменение размера холста при изменении размера окна
         window.addEventListener("resize", () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
         });
      </script>
      <!-- Code injected by live-server -->
      <script>
         // <![CDATA[  <-- For SVG support
         if ("WebSocket" in window) {
            (function () {
               function refreshCSS() {
                  var sheets = [].slice.call(document.getElementsByTagName("link"));
                  var head = document.getElementsByTagName("head")[0];
                  for (var i = 0; i < sheets.length; ++i) {
                     var elem = sheets[i];
                     var parent = elem.parentElement || head;
                     parent.removeChild(elem);
                     var rel = elem.rel;
                     if (
                        (elem.href && typeof rel != "string") ||
                        rel.length == 0 ||
                        rel.toLowerCase() == "stylesheet"
                     ) {
                        var url = elem.href.replace(/(&|\?)_cacheOverride=\d+/, "");
                        elem.href =
                           url + (url.indexOf("?") >= 0 ? "&" : "?") + "_cacheOverride=" + new Date().valueOf();
                     }
                     parent.appendChild(elem);
                  }
               }
               var protocol = window.location.protocol === "http:" ? "ws://" : "wss://";
               var address = protocol + window.location.host + window.location.pathname + "/ws";
               var socket = new WebSocket(address);
               socket.onmessage = function (msg) {
                  if (msg.data == "reload") window.location.reload();
                  else if (msg.data == "refreshcss") refreshCSS();
               };
               if (sessionStorage && !sessionStorage.getItem("IsThisFirstTime_Log_From_LiveServer")) {
                  console.log("Live reload enabled.");
                  sessionStorage.setItem("IsThisFirstTime_Log_From_LiveServer", true);
               }
            })();
         } else {
            console.error("Upgrade your browser. This Browser is NOT supported WebSocket for Live-Reloading.");
         }
         // ]]>
      </script>
   </body>
</html>
